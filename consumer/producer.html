
<html>
<head>
<title>Geometry Tracer Consumer</title>
<!-- Importing the math library -->
<script type="text/javascript" src="math.js"></script>
<!-- Importing the webgl interface -->
<script type="text/javascript" src="webgl-utils.js"></script>
<!-- Importing the shader interface -->
<script type="text/javascript" src="shader.js"></script>
<!-- Importing the render interface -->
<script type="text/javascript" src="render.js"></script>
<!-- Importing the tools interface -->
<script type="text/javascript" src="tools.js"></script>
<!-- Importing the tracer interface -->
<script type="text/javascript" src="tracer.js"></script>

<!-- Declaration du fragment shader -->
<script id="basicFragment" type="glsl/frag">
    // Declaration de la précision des flottants
    precision mediump float;
    // Attributs interpolés par la pipeline WebGL
    // Normale normalisée en espace monde
    varying vec3 normal;
    // Coordonnées de textures pour la sphere
    varying vec2 texcoord;

    // position du fragment dans l'espace monde
    void main(void) 
    {
        gl_FragColor = vec4(1.0,0.0,0.0,1.0);
    }
</script>

<!-- Declaration du vertex shader -->
<script id="basicVertex" type="glsl/vertex">
    //Attributs passés en attribute
    // Position du vertex en espace objet
    attribute vec3 VertexPosition;
    // Normale du vertex en espace objet
    attribute vec3 VertexNormal;
    // Coordonnées textures pour le vertex
    attribute vec2 VertexTexCoord;

    // Matrice de projection    
    uniform mat4 ProjMatrix;
    // Matrice de vue
    uniform mat4 ViewMatrix;
    // Matrice de modele
    uniform mat4 ModelMatrix;
    // Matrice normale (Inverse de la matrice de modèle pour les normales)
    uniform mat4 NormalMatrix;

    // Données à Injecter dans le fragment shader
    // Normale normalisée en espace monde
    varying vec3 normal;
    // Coordnnées texture
    varying vec2 texcoord;

    void main(void) 
    {
        vec3 ecPos = (ModelMatrix * vec4(VertexPosition,1.0)).xyz;
        // Conversion en coordnnées clipping
        gl_Position = ProjMatrix * ViewMatrix * vec4(ecPos,1.0);
        // Normalisation et conversion en espace monde
        normal = normalize(NormalMatrix*vec4(VertexNormal,0.0)).xyz;
        // coordonnées de texture
        texcoord = VertexTexCoord;
    }
</script>


<script type="text/javascript">

    // Variables gobales
    var gl;
    var canvas;

    // Camera 
    var camera = [];

    // Scene objects
    var sceneObjects = [];

    // Init the camera object
    function initCamera()
    {
        camera.projectionMatrix = mat4.create();
        // On définie la matrice de projection
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, camera.projectionMatrix);
        // On définie la matrice de vue
        camera.viewMatrix = mat4.create();
        mat4.identity(camera.viewMatrix);
    }

    // Init a shader program for an object
    function initShaderData(_program, _object)
    {
        // On bind le vertex buffer object de position
        _program.vertexPositionAttribute = gl.getAttribLocation(_program, "VertexPosition");
        
        // On bind le vertex buffer object de normale
        _program.vertexNormalAttribute = gl.getAttribLocation(_program, "VertexNormal");

        // On bind le vertex buffer object de tex coord
        _program.vertexTexCoordAttribute = gl.getAttribLocation(_program, "VertexTexCoord");

        // On récupère l'index la matrice de projection
        _program.projMatrix = gl.getUniformLocation(_program, "ProjMatrix");
        // On récupère l'index la matrice de vue
        _program.viewMatrix = gl.getUniformLocation(_program, "ViewMatrix");
        // On récupère l'index de la normal matrix
        _program.normalMatrix = gl.getUniformLocation(_program, "NormalMatrix");

        // On récupère l'index la matrice de modele
        _program.modelMatrix = gl.getUniformLocation(_program, "ModelMatrix");

        // Injection de la projection matrix
        gl.uniformMatrix4fv(_program.projMatrix, false, camera.projectionMatrix);

        //Injection de s données de réfléctance
        gl.uniform3fv(_program.colorUniform, _object.colorVal);   
    }

    function updateCamera(_shader)
    {
        // Injection de la view matrix
        gl.uniformMatrix4fv(_shader.viewMatrix, false, camera.viewMatrix);

    }

    function updateObject(_object) 
    {
        //Injection de la model matrix
        gl.uniformMatrix4fv(_object.shaderProgram.modelMatrix, false, _object.modelMatrix);

        // Injection de la normal matrix
        var normalMatrix = mat4.create();
        mat4.inverse(_object.modelMatrix, normalMatrix);
        gl.uniformMatrix4fv(_object.shaderProgram.normalMatrix, false, normalMatrix);
    }

    function createScene() 
    {
        var sourceLumiere3 = createQuad([20, -20, -150], [20, 20, -150],  [-20, -20, -150],[-20, 20, -150],  [0.066, 0.066, 1.0]);
        sourceLumiere3.shaderProgram = generateProgram("basicVertex", "basicFragment");
        sourceLumiere3.modelMatrix = mat4.create();
        mat4.identity(sourceLumiere3.modelMatrix);
        mat4.translate(sourceLumiere3.modelMatrix,sourceLumiere3.position);
        initShaderData(sourceLumiere3.shaderProgram, sourceLumiere3);
        sourceLumiere3.isOutDated = true;

        sceneObjects.push(sourceLumiere3);

    }

    function drawObject(_object)
    {
        // ON bind le pos buffer 
        gl.enableVertexAttribArray(_object.shaderProgram.vertexPositionAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, _object.vertexPositionBuffer);
        gl.vertexAttribPointer(_object.shaderProgram.vertexPositionAttribute, _object.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        // ON bind le normal buffer 
        gl.enableVertexAttribArray(_object.shaderProgram.vertexNormalAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, _object.vertexNormalBuffer);
        gl.vertexAttribPointer(_object.shaderProgram.vertexNormalAttribute, _object.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0); 

        // ON bind le texcoord buffer 
        gl.enableVertexAttribArray(_object.shaderProgram.vertexTexCoordAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, _object.vertexTextureCoordBuffer);
        gl.vertexAttribPointer(_object.shaderProgram.vertexTexCoordAttribute, _object.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);                

        // On bind l'IBO
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _object.vertexIndexBuffer);
        // On injecte les données spécifique à la sphère
        updateObject(_object) 
        // On déssine la sphère
        gl.drawElements(gl.TRIANGLES, _object.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        gl.disableVertexAttribArray(_object.shaderProgram.vertexPositionAttribute);
        gl.disableVertexAttribArray(_object.shaderProgram.vertexNormalAttribute);
        gl.disableVertexAttribArray(_object.shaderProgram.vertexTexCoordAttribute);

    }

    function drawObjects()
    {
        for(var i = 0; i < sceneObjects.length;++i)
        {
            bindProgram(sceneObjects[i].shaderProgram);
            updateCamera(sceneObjects[i].shaderProgram);
            drawObject(sceneObjects[i]);
            unbindProgram();
        }       
    }
    function drawScene() 
    {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        drawObjects()
    }

    function pre_render()
    {
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.enable(gl.DEPTH_TEST);
    }


    function renderLoop()
    {
        window.requestAnimFrame(renderLoop);
        drawScene();        
    }

    function main() 
    {
        // Récupération du canvas
        canvas = document.getElementById("canvas");

        // Initialisation du contexte WebGL
        initGL(canvas);

        // Initialisation de la camera
        initCamera();

        // Initialisation de la scene
        createScene();

        pre_render();
        renderLoop();
    }

</script>
</head>

<body onload="main();">
    <canvas id="canvas" style="border: none;" width="1280" height="720"></canvas>
</body>

</html>
