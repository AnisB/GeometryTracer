
<html>
<head>
<title>Geometry Tracer Consumer</title>
<!-- Importing the math library -->
<script type="text/javascript" src="math.js"></script>
<!-- Importing the webgl interface -->
<script type="text/javascript" src="webgl-utils.js"></script>
<!-- Importing the shader interface -->
<script type="text/javascript" src="shader.js"></script>
<!-- Importing the render interface -->
<script type="text/javascript" src="render.js"></script>
<!-- Importing the tools interface -->
<script type="text/javascript" src="tools.js"></script>

<!-- Declaration du fragment shader -->
<script id="basicFragment" type="glsl/frag">
    // Declaration de la précision des flottants
    precision mediump float;
    // Attributs interpolés par la pipeline WebGL
    // Normale normalisée en espace monde
    varying vec3 normal;
    // Coordonnées de textures pour la sphere
    varying vec2 texcoord;

    // position du fragment dans l'espace monde
    void main(void) 
    {
        gl_FragColor = vec4(1.0,0.0,0.0,1.0);
    }
</script>

<!-- Declaration du vertex shader -->
<script id="basicVertex" type="glsl/vertex">
    //Attributs passés en attribute
    // Position du vertex en espace objet
    attribute vec3 VertexPosition;
    // Normale du vertex en espace objet
    attribute vec3 VertexNormal;
    // Coordonnées textures pour le vertex
    attribute vec2 VertexTexCoord;

    // Matrice de projection    
    uniform mat4 ProjMatrix;
    // Matrice de vue
    uniform mat4 ViewMatrix;
    // Matrice de modele
    uniform mat4 ModelMatrix;
    // Matrice normale (Inverse de la matrice de modèle pour les normales)
    uniform mat4 NormalMatrix;

    // Données à Injecter dans le fragment shader
    // Normale normalisée en espace monde
    varying vec3 normal;
    // Coordnnées texture
    varying vec2 texcoord;

    void main(void) 
    {
        vec3 ecPos = (ModelMatrix * vec4(VertexPosition,1.0)).xyz;
        // Conversion en coordnnées clipping
        gl_Position = ProjMatrix * ViewMatrix * vec4(ecPos,1.0);
        // Normalisation et conversion en espace monde
        normal = normalize(NormalMatrix*vec4(VertexNormal,0.0)).xyz;
        // coordonnées de texture
        texcoord = VertexTexCoord;
    }
</script>


<script type="text/javascript">

    // Variables gobales
    var gl;
    var canvas;

    // Camera 
    var camera = [];

    // Init the camera object
    function initCamera()
    {
        camera.projectionMatrix = mat4.create();
        // On définie la matrice de projection
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, camera.projectionMatrix);
        // On définie la matrice de vue
        camera.viewMatrix = mat4.create();
        mat4.identity(camera.viewMatrix);
    }

    // Init a shader program for an object
    function initShaderData(_program, _object)
    {
        // On bind le vertex buffer object de position
        _program.vertexPositionAttribute = gl.getAttribLocation(_program, "VertexPosition");
        
        // On bind le vertex buffer object de normale
        _program.vertexNormalAttribute = gl.getAttribLocation(_program, "VertexNormal");

        // On bind le vertex buffer object de tex coord
        _program.vertexTexCoordAttribute = gl.getAttribLocation(_program, "VertexTexCoord");

        // On récupère l'index la matrice de projection
        _program.projMatrix = gl.getUniformLocation(_program, "ProjMatrix");
        // On récupère l'index la matrice de vue
        _program.viewMatrix = gl.getUniformLocation(_program, "ViewMatrix");
        // On récupère l'index de la normal matrix
        _program.normalMatrix = gl.getUniformLocation(_program, "NormalMatrix");

        // On récupère l'index la matrice de modele
        _program.modelMatrix = gl.getUniformLocation(_program, "ModelMatrix");

        // Injection de la projection matrix
        gl.uniformMatrix4fv(_program.projMatrix, false, camera.projectionMatrix);

        //Injection de s données de réfléctance
        gl.uniform3fv(_program.colorUniform, _object.colorVal);   
    }

    function updateCamera(_shader)
    {
        // Injection de la view matrix
        gl.uniformMatrix4fv(_shader.viewMatrix, false, camera.viewMatrix);

    }

    function updateObject(_object) 
    {
        //Injection de la model matrix
        gl.uniformMatrix4fv(_object.shaderProgram.modelMatrix, false, _object.modelMatrix);

        // Injection de la normal matrix
        var normalMatrix = mat4.create();
        mat4.inverse(_object.modelMatrix, normalMatrix);
        gl.uniformMatrix4fv(_object.shaderProgram.normalMatrix, false, normalMatrix);
    }

    function createScene() 
    {
        // On crée les sphères
        var sphereOne = createSphere(10,[-30 , -10,-100], [0.3, 0.5, 0.75],200);
        sphereOne.shaderProgram = generateProgram("basicVertex", "lightSurface");
        sphereOne.modelMatrix = mat4.create();
        mat4.identity(sphereOne.modelMatrix);
        mat4.translate(sphereOne.modelMatrix,sphereOne.position);
        initShaderData(sphereOne.shaderProgram, sphereOne);
        sphereOne.isOutDated = true;

        sceneObjects.push(sphereOne);


        // // On crée les sphères
        var sphereTwo = createSphere(10,[30, -10,-100],[1.0, 0.5, 0.75],200);
        sphereTwo.shaderProgram = generateProgram("basicVertex", "lightSurface");
        sphereTwo.modelMatrix = mat4.create();
        mat4.identity(sphereTwo.modelMatrix);
        mat4.translate(sphereTwo.modelMatrix,sphereTwo.position);
        initShaderData(sphereTwo.shaderProgram, sphereTwo);
        sphereTwo.isOutDated = true;

        sceneObjects.push(sphereTwo);
        
    
        // // On crée les sphères
        var sphereThree = createSphere(10,[0, -10,-100],[0.2, 0.5, 0.3],200);
        sphereThree.shaderProgram = generateProgram("basicVertex", "lightSurface");
        sphereThree.modelMatrix = mat4.create();
        mat4.identity(sphereThree.modelMatrix);
        mat4.translate(sphereThree.modelMatrix,sphereThree.position);
        initShaderData(sphereThree.shaderProgram, sphereThree);
        sphereThree.isOutDated = true;

        sceneObjects.push(sphereThree);

        var sphereFour = createSphere(10,[-60, -10,-100],[0.2, 0.5, 0.3],200);
        sphereFour.shaderProgram = generateProgram("basicVertex", "lightSurface");
        sphereFour.modelMatrix = mat4.create();
        mat4.identity(sphereFour.modelMatrix);
        mat4.translate(sphereFour.modelMatrix,sphereFour.position);
        initShaderData(sphereFour.shaderProgram, sphereFour);
        sphereFour.isOutDated = true;

        sceneObjects.push(sphereFour);


        var sphereFive = createSphere(10,[60, -10,-100],[0.2, 0.5, 0.3],200);
        sphereFive.shaderProgram = generateProgram("basicVertex", "lightSurface");
        sphereFive.modelMatrix = mat4.create();
        mat4.identity(sphereFive.modelMatrix);
        mat4.translate(sphereFive.modelMatrix,sphereFive.position);
        initShaderData(sphereFive.shaderProgram, sphereFive);
        sphereFive.isOutDated = true;

        sceneObjects.push(sphereFive);

        // // On crée les sphères
        var plan = createQuad([-100, -20, -150], [100, -20, -150], [-100, -20, -50], [100, -20, -50],  [1.0, 1.0, 1.0]);
        plan.shaderProgram = generateProgram("basicVertex", "lightSurface");
        plan.modelMatrix = mat4.create();
        mat4.identity(plan.modelMatrix);
        mat4.translate(plan.modelMatrix,plan.position);
        initShaderData(plan.shaderProgram, plan);
        plan.isOutDated = true;

        sceneObjects.push(plan);

        var sourceLumiere1 = createQuad([-100, -20, -120], [-100, 20, -120],  [-100, -20, -80],[-100, 20, -80],  [0.066, 1.0, 0.066]);
        sourceLumiere1.shaderProgram = generateProgram("basicVertex", "basicFragment");
        sourceLumiere1.modelMatrix = mat4.create();
        mat4.identity(sourceLumiere1.modelMatrix);
        mat4.translate(sourceLumiere1.modelMatrix,sourceLumiere1.position);
        initShaderData(sourceLumiere1.shaderProgram, sourceLumiere1);
        sourceLumiere1.isOutDated = true;

        sources.push(sourceLumiere1);

        var sourceLumiere2 = createQuad([100, -20, -120], [100, 20, -120],  [100, -20, -80],[100, 20, -80],  [1.0, 0.066, 0.066]);
        sourceLumiere2.shaderProgram = generateProgram("basicVertex", "basicFragment");
        sourceLumiere2.modelMatrix = mat4.create();
        mat4.identity(sourceLumiere2.modelMatrix);
        mat4.translate(sourceLumiere2.modelMatrix,sourceLumiere2.position);
        initShaderData(sourceLumiere2.shaderProgram, sourceLumiere2);
        sourceLumiere2.isOutDated = true;

        sources.push(sourceLumiere2);

        var sourceLumiere3 = createQuad([20, -20, -150], [20, 20, -150],  [-20, -20, -150],[-20, 20, -150],  [0.066, 0.066, 1.0]);
        sourceLumiere3.shaderProgram = generateProgram("basicVertex", "basicFragment");
        sourceLumiere3.modelMatrix = mat4.create();
        mat4.identity(sourceLumiere3.modelMatrix);
        mat4.translate(sourceLumiere3.modelMatrix,sourceLumiere3.position);
        initShaderData(sourceLumiere3.shaderProgram, sourceLumiere3);
        sourceLumiere3.isOutDated = true;

        sources.push(sourceLumiere3);

    }

    function drawObject(_object)
    {
        // ON bind le pos buffer 
        gl.enableVertexAttribArray(parObj.shaderProgram.vertexPositionAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, parObj.vertexPositionBuffer);
        gl.vertexAttribPointer(parObj.shaderProgram.vertexPositionAttribute, parObj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        // ON bind le normal buffer 
        gl.enableVertexAttribArray(parObj.shaderProgram.vertexNormalAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, parObj.vertexNormalBuffer);
        gl.vertexAttribPointer(parObj.shaderProgram.vertexNormalAttribute, parObj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0); 

        // ON bind le texcoord buffer 
        gl.enableVertexAttribArray(parObj.shaderProgram.vertexTexCoordAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, parObj.vertexTextureCoordBuffer);
        gl.vertexAttribPointer(parObj.shaderProgram.vertexTexCoordAttribute, parObj.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);                

        // On bind l'IBO
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, parObj.vertexIndexBuffer);
        // On injecte les données spécifique à la sphère
        injectSpecificUniforms(parObj) 
        // On déssine la sphère
        gl.drawElements(gl.TRIANGLES, parObj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        gl.disableVertexAttribArray(parObj.shaderProgram.vertexPositionAttribute);
        gl.disableVertexAttribArray(parObj.shaderProgram.vertexNormalAttribute);
        gl.disableVertexAttribArray(parObj.shaderProgram.vertexTexCoordAttribute);

    }
    function renderLight(parColor, parP1, parP2, parP3, parP4)
    {
        for(var i = 0; i < sceneObjects.length;++i)
        {
            bindProgram(sceneObjects[i].shaderProgram);
            injectGenericUniforms(sceneObjects[i].shaderProgram, parColor, parP1, parP2, parP3, parP4);
            drawObject(sceneObjects[i]);
            unbindProgram();
        }   
        for(var i = 0; i < sources.length;++i)
        {
            bindProgram(sources[i].shaderProgram);
            injectQuad(sources[i].shaderProgram, parColor, parP1, parP2, parP3, parP4);
            drawObject(sources[i]);
            unbindProgram();
        }    
    }
    function drawScene() 
    {
        // On définie le viewport
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        // On injecte les données communes
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        // On rend une fois par quad lumineux un peu comme du defered shading 
        gl.blendEquation (gl.FUNC_ADD);
        gl.blendFunc (gl.ONE, gl.ONE);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        renderLight([0.2, 1.0, 0.2], [-100, 20, -120], [-100, -20, -120], [-100, -20, -80],[-100, 20, -80])
        gl.enable (gl.BLEND);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        renderLight([1.0, 0.2, 0.2],[100, -20, -80],[100, -20, -120], [100, 20, -120],  [100, 20, -80]);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        renderLight([0.2, 0.2, 1.0],   [-20, -20, -150],  [-20, 20, -150],  [20, 20, -150],[20, -20, -150]);
        gl.disable (gl.BLEND);
        if(camera.isOutDated)
        {
            camera.isOutDated = false;
        }
    }

    function pre_render()
    {
        gl.clearColor(0.5, 0.5, 0.5, 1.0);
        gl.enable(gl.DEPTH_TEST);
    }


    function renderLoop()
    {
        window.requestAnimFrame(renderLoop);
        drawScene();        
    }
    function main() 
    {
        // Récupération du canvas
        canvas = document.getElementById("canvas");

        // Initialisation du contexte WebGL
        initGL(canvas);

        // Initialisation de la camera
        initCamera();

        // Initialisation de la scene
        createScene();

        pre_render();
        renderLoop();
    }

</script>
</head>

<body onload="main();">
    <canvas id="canvas" style="border: none;" width="1280" height="720"></canvas>
</body>

</html>
